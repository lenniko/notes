## 1.如何区分同步和异步？

当一个方法被调用时，调用者需要等待该方法执行完毕并返回才能继续执行，我们称这个方法是同步方法；当一个方法被调用时立即返回，并获取一个线程执行该方法内部的业务，调用者不用等待该方法执行完毕，我们称这个方法为异步方法。

## 2.异步的好处是什么？
异步的好处在于非阻塞(调用线程不会暂停执行去等待子线程完成)，因此把一些不需要立即使用结果、较耗时的任务设为异步执行，可以提高程序的运行效率。net4.0在ThreadPool的基础上推出了Task类，微软极力推荐使用Task来执行异步任务，现在C#类库中的异步方法基本都用到了Task；net5.0推出了async/await，让异步编程更为方便。
## 3.多线程和Task介绍
线程被定义为程序的执行路径。每个线程都定义了一个独特的控制流。如果应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的，每个线程执行特定的工作。
### 3.1 ThreadPool
ThreadPool中有若干数量的线程，如果有任务需要处理时，会从线程池中获取一个空闲的线程来执行任务，任务执行完毕后线程不会销毁，而是被线程池回收以供后续任务使用。当线程池中所有的线程都在忙碌时，又有新任务要处理时，线程池才会新建一个线程来处理该任务，如果线程数量达到设置的最大值，任务会排队，等待其他任务释放线程后再执行。线程池能减少线程的创建，节省开销。

```
static void Main()
    {
        Console.WriteLine("hello world");
        for (int i = 0; i <= 10; i++)
        {
            ThreadPool.QueueUserWorkItem(new WaitCallback((obj) =>
            {
                Console.WriteLine($"第{obj}个执行任务");
            }), i);
        }
        Console.ReadKey();
    }
```
上述代码示例从线程池中获取10个线程执行任务，ThreadPool相对于Thread来说可以减少线程的创建，有效减小系统开销；但是ThreadPool不能控制线程的执行顺序，我们也不能获取线程池内线程取消/异常/完成的通知，即我们不能有效监控和控制线程池中的线程
### 3.2 Task
ask出现之前，微软的多线程处理方式有：Thread→ThreadPool→委托的异步调用，虽然也可以满足基本业务需要的多线程场景，但它们在多个线程的等待处理方面、资源占用方面、线程延续和阻塞方面、线程的取消方面等都显得比较笨拙，在面对复杂的业务场景下，显得有点捉襟见肘了。ThreadPool相比Thread来说具备了很多优势，但是ThreadPool却又存在一些使用上的不方便。比如：ThreadPool不支持线程的取消、完成、失败通知等交互性操作；
ThreadPool不支持线程执行的先后次序；正是在这种背景下，Task应运而生。

net4.0在ThreadPool的基础上推出了Task，Task拥有线程池的优点，同时也解决了使用线程池不易控制的弊端。Task看起来像一个Thread，实际上，它是在ThreadPool的基础上进行的封装，Task的控制和扩展性很强，在线程的延续、阻塞、取消、超时等方面远胜于Thread和ThreadPool。
#### 3.2.1 Task的创建和运行
方式：调用Start方法
```
var t1 = new Task(() => TaskMethod("Task 1"))；
t1.start();
Task.WaitAll(t1);
```
方式2：静态方法Run
```
Task.Run(() => TaskMethod("Task 2"));
```
方式3：TaskFactory工厂